{
  "hash": "87a5660eeea6b9143bdd4d06732488c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntopic: \"Joining Multiple Tables\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n# {{< meta topic >}}\n\n## Where are We?\n\n::: {style=\"font-size: 85%;\"}\n- `R` Basics\n- Data Visualization\n- `R` Programming\n- [Tidy Data Manipulation]{color=\"blue\"}\n  - Selecting Rows and Columns\n  - Computing Groupwise Summaries\n  - [Joining Tables]{color=\"blue\"}\n  - Reshaping Tables\n- `python` Basics\n- Web Scraping with `python`\n\n:::\n\n## Goals for this Video\n\nIn this video: \n\n::: incremental\n\n- Identify suitable _keys_ \n- Understand different types of `join` operators\n- Specify columns to be used in joins\n\n:::\n\n## Combining Tables\n\nOften in data analysis, we combine data from multiple sources to create new insights\n\n`join`s provide us a unified framework for combining data sets\n\n## New Example Data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nband_members\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name  band   \n  <chr> <chr>  \n1 Mick  Stones \n2 John  Beatles\n3 Paul  Beatles\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nband_instruments\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name  plays \n  <chr> <chr> \n1 John  guitar\n2 Paul  bass  \n3 Keith guitar\n```\n\n\n:::\n:::\n\n\n\n## New Example Data\n\nPartial alignment on `name`\n\nMissing:\n\n- Keith (Richards) of the Rolling Stones in `band_members`\n- Mick (Jagger) as a guitarist in `band_instruments`\n\n## Table Keys\n\nRecall the concept of a _key_ - a unique identifier in a table\n\n- Ideally a single column (e.g., Employee ID)\n- Sometimes several columns (name + birth date)\n\nIn our example, `name` is a key we can use\n\n## Your First Join\n\nRecall our two data sets\n\n+-------------------+-------------------+\n| `band_instruments`| `band_members`    |\n+========+==========+========+==========+\n| `name` | `plays`  | `name` | `band`   |\n+--------+----------+--------+----------+\n| John   | guitar   | Mick   | Stones   |\n+--------+----------+--------+----------+\n| Paul   | bass     | John   | Beatles  |\n+--------+----------+--------+----------+\n| Keith  | guitar   | Paul   | Beatles  |\n+--------+----------+--------+----------+\n\n## Your First Join\n\nTo use `name` as a key, reorder rows so that `name` matches\n\n+-------------------+-------------------+\n| `band_instruments`| `band_members`    |\n+========+==========+========+==========+\n| `name` | `plays`  | `name` | `band`   |\n+--------+----------+--------+----------+\n| John   | guitar   | John   | Beatles  |\n+--------+----------+--------+----------+\n| Paul   | bass     | Paul   | Beatles  |\n+--------+----------+--------+----------+\n| Keith  | guitar   |        |          |\n+--------+----------+--------+----------+\n|        |          | Mick   | Stones   |\n+--------+----------+--------+----------+\n\n\n\n## Your First Join\n\nNote that `Keith` and `Mick` don't have a matching row\n\n+-------------------+-------------------+\n| `band_instruments`| `band_members`    |\n+========+==========+========+==========+\n| `name` | `plays`  | `name` | `band`   |\n+--------+----------+--------+----------+\n| John   | guitar   | John   | Beatles  |\n+--------+----------+--------+----------+\n| Paul   | bass     | Paul   | Beatles  |\n+--------+----------+--------+----------+\n| Keith  | guitar   |        |          |\n+--------+----------+--------+----------+\n|        |          | Mick   | Stones   |\n+--------+----------+--------+----------+\n\n## Your First Join\n\nWe will definitely keep \n\n+-------------------+-------------------+\n| `band_instruments`| `band_members`    |\n+========+==========+========+==========+\n| `name` | `plays`  | `name` | `band`   |\n+--------+----------+--------+----------+\n| John   | guitar   | John   | Beatles  |\n+--------+----------+--------+----------+\n| Paul   | bass     | Paul   | Beatles  |\n+--------+----------+--------+----------+\n\nNeed to decide on unmatched rows\n\n## Your First Inner Join\n\n`inner_join` - keep only rows with matches\n\n| `name` | `plays` | `band`  |\n|--------|---------|---------|\n| John   | guitar  | Beatles |\n| Paul   | bass    | Beatles |\n\n## Your First Full Join\n\n`full_join` - keep _all_ rows and fill with `NA`\n\n| `name` | `plays` | `band`  |\n|--------|---------|---------|\n| John   | guitar  | Beatles |\n| Paul   | bass    | Beatles |\n| Keith  | guitar  | `NA`    |\n| Mick   | `NA`    | Stones  |\n\n## Your First Left Join\n\n`left_join` - keep unmatched rows from first (\"left\") table\n\n\n| `name` | `plays` | `band`  |\n|--------|---------|---------|\n| John   | guitar  | Beatles |\n| Paul   | bass    | Beatles |\n| Keith  | guitar  | `NA`    |\n\n\n## Your First Right Join\n\n`right_join` - keep unmatched rows from first (\"right\") table\n\n\n| `name` | `plays` | `band`  |\n|--------|---------|---------|\n| John   | guitar  | Beatles |\n| Paul   | bass    | Beatles |\n| Mick   | `NA`    | Stones  |\n\n## Types of Joins\n\n\nFigure from *`R` for Data Science*\n\n\n![](https://r4ds.hadley.nz/diagrams/join/venn.png){width=\"80%\"}\n\n\nFigure from *`R` for Data Science*\n\n## Specifying Joins\n\nIn `R`, we specify joins with the `join_by` function\n\n\n\n::: {.cell}\n\n:::\n\n\n\n`join_by` gives a \"Join Specification\"\n\n- `name` == `name` are column names from first and second table\n- Be explicit or `R` will \"auto-guess\" based on names matched\n\n## inner_join\n\n`inner_join` discards unmatched rows\n\n![](https://r4ds.hadley.nz/diagrams/join/inner.png){width=\"40%\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  name  plays  band   \n  <chr> <chr>  <chr>  \n1 John  guitar Beatles\n2 Paul  bass   Beatles\n```\n\n\n:::\n:::\n\n\n\n## full_join\n\n`full_join` keeps all rows\n\n![](https://r4ds.hadley.nz/diagrams/join/full.png){width=\"40%\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  name  plays  band   \n  <chr> <chr>  <chr>  \n1 John  guitar Beatles\n2 Paul  bass   Beatles\n3 Keith guitar <NA>   \n4 Mick  <NA>   Stones \n```\n\n\n:::\n:::\n\n\n\n\n## left_join\n\n`left_join` keeps unmatched rows from first table\n\n![](https://r4ds.hadley.nz/diagrams/join/left.png){width=\"40%\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  name  plays  band   \n  <chr> <chr>  <chr>  \n1 John  guitar Beatles\n2 Paul  bass   Beatles\n3 Keith guitar <NA>   \n```\n\n\n:::\n:::\n\n\n\n## right_join\n\n`right_join` flips `left_join`\n\n\n![](https://r4ds.hadley.nz/diagrams/join/right.png){width=\"40%\"}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  name  plays  band   \n  <chr> <chr>  <chr>  \n1 John  guitar Beatles\n2 Paul  bass   Beatles\n3 Mick  <NA>   Stones \n```\n\n\n:::\n:::\n\n\n\n## Picking a Join\n\nType of join depends on treatment of missing values\n\n- Why is data missing? \n- If going to `na.rm=TRUE`, `inner_join`\n- If going to investigate further, `full` or `left`/`right`\n\n## Specifying Column Names\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nband_instruments2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  artist plays \n  <chr>  <chr> \n1 John   guitar\n2 Paul   bass  \n3 Keith  guitar\n```\n\n\n:::\n:::\n\n\n\nSame as before, but now `name` -> `artist`\n\n## Specifying Names\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(band_instruments2, \n           band_members, \n           join_by(artist == name))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  artist plays  band   \n  <chr>  <chr>  <chr>  \n1 John   guitar Beatles\n2 Paul   bass   Beatles\n```\n\n\n:::\n:::\n\n\n\n## Computing Z-Scores\n\nLet's compute the `z`-scores of mass for our penguins by species\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_stats <- penguins |>\n    group_by(species) |>\n    summarize(mass_mean = mean(body_mass_g, na.rm=TRUE), \n              mass_sd = sd(body_mass_g, na.rm=TRUE))\n\npenguin_stats\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  species   mass_mean mass_sd\n  <fct>         <dbl>   <dbl>\n1 Adelie        3701.    459.\n2 Chinstrap     3733.    384.\n3 Gentoo        5076.    504.\n```\n\n\n:::\n:::\n\n\n\n## Computing Z-Scores\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n    inner_join(penguin_stats, \n               join_by(species == species)) |>\n    select(species, body_mass_g, mass_mean, mass_sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 4\n   species body_mass_g mass_mean mass_sd\n   <fct>         <int>     <dbl>   <dbl>\n 1 Adelie         3750     3701.    459.\n 2 Adelie         3800     3701.    459.\n 3 Adelie         3250     3701.    459.\n 4 Adelie           NA     3701.    459.\n 5 Adelie         3450     3701.    459.\n 6 Adelie         3650     3701.    459.\n 7 Adelie         3625     3701.    459.\n 8 Adelie         4675     3701.    459.\n 9 Adelie         3475     3701.    459.\n10 Adelie         4250     3701.    459.\n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n\n\n## Computing Z-Scores\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n    inner_join(penguin_stats, \n               join_by(species == species)) |>\n    mutate(mass_z = (body_mass_g - mass_mean) / mass_sd) |>\n    select(species, body_mass_g, mass_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 3\n   species body_mass_g mass_z\n   <fct>         <int>  <dbl>\n 1 Adelie         3750  0.108\n 2 Adelie         3800  0.217\n 3 Adelie         3250 -0.983\n 4 Adelie           NA NA    \n 5 Adelie         3450 -0.547\n 6 Adelie         3650 -0.110\n 7 Adelie         3625 -0.165\n 8 Adelie         4675  2.12 \n 9 Adelie         3475 -0.492\n10 Adelie         4250  1.20 \n# ℹ 334 more rows\n```\n\n\n:::\n:::\n\n\n\n## Computing Z-Scores\n\nJoin onto summary statistics to get group (species) statistics\n\n`inner_join` since we know all penguins match to one species\n\n## Looking Ahead\n\n- Apply Grouped Operations ✅ \n- Summarize Across Multiple Rows ✅ \n- Join Multiple Tables ✅ \n- Reshape Tables with `pivot` Operations\n\n## Learning More\n\nFor more, check out \n[Chapter 19 - \"Joins\"](https://r4ds.hadley.nz/joins.html) \nof *`R` for Data Science*\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}