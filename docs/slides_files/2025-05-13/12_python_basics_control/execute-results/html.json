{
  "hash": "a9f1553a9be1873985c80ea0d76e7e17",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntopic: \"`python` Basics: Control Flow\"\n---\n\n\n\n\n\n\n\n# {{< meta topic >}}\n\n## Where are We?\n\n::: {style=\"font-size: 85%;\"}\n- `R` Basics\n- Data Visualization\n- `R` Programming\n- Tidy Data Manipulation\n- [`python` Basics]{color=\"blue\"}\n  - Installing `python`\n  - [Basic Syntax and Control Flow]{color=\"blue\"}\n  - `python` Objects\n  - Using Packages\n- Web Scraping with `python`\n\n:::\n\n\n## Goals for this Video\n\nIn this video: \n\n::: incremental\n\n- Block-based Control Flow\n- Iterating over Containers\n- Function Calls\n- Defining Functions\n\n:::\n\n## Control Flow\n\nRecall in `R`, \"blocks\" of code were delimited by braces `{}`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -3\nif(x > 0){\n    print(\"x is positive\")\n} else {\n    print(\"x is negative\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x is negative\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Control Flow\n\n`python` uses _indented_ blocks instead: \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 1\nif x > 0:\n    print(\"x is positive\")\nelse:\n    print(\"x is negative\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx is positive\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNo _explicit_ end - just next non-indented line\n\n## Control Flow\n\nIf you've used good formatting in `R`, won't be a huge shift\n\n. . . \n\nTricky at command line (have to manually indent whole blocks): \n\n- notebook based execution preferred \n\n. . . \n\nYou _must_ be consistent (number of spaces, tabs vs spaces)\n\n- Recommendation: 4 spaces per 'level'\n\n## Control Flow\n\nNesting requires multiple indents:\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 100\nif x > 0:\n    print(\"x is positive\")\n    \n    if x >= 100: \n        print(\"x has three digits\")\nelse:\n    print(\"x is negative\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx is positive\nx has three digits\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Control Flow\n\n`python` provides an `elif` where in `R` we used `else if`: \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 0\nif x > 0:\n    print(\"x is positive\")\nelif x < 0:\n    print(\"x is negative\")\nelse: \n    print(\"x is zero\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx is zero\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNeither `elif` or `else` are required, but `else` must be last\n\n## Looping\n\nUnlike `R`, explicit loops are common (and good!) in `python`\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlist_of_numbers = [1, 2, 3]\nfor number in list_of_numbers:\n    print(\"The number is\", number)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe number is 1\nThe number is 2\nThe number is 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Looping\n\nLoops over `list`s and `tuple`s are \"natural\"\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmy_tuple = (1, 2, \"fish\", [\"bottle\", \"of\", \"rum\"])\nfor item in my_tuple:\n    print(item)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n2\nfish\n['bottle', 'of', 'rum']\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Looping\n\nOften we want to loop and count: `enumerate`\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmy_courses = [\"STA 9750\", \"STA 9708\", \"STA 9700\"]\nfor num, course in enumerate(my_courses):\n    print(\"Course Number\", num, \"is\", course)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCourse Number 0 is STA 9750\nCourse Number 1 is STA 9708\nCourse Number 2 is STA 9700\n```\n\n\n:::\n:::\n\n\n\n\n\n\n. . . \n\nRecall 0-based, so you may prefer\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmy_courses = [\"STA 9750\", \"STA 9708\", \"STA 9700\"]\nfor num, course in enumerate(my_courses):\n    print(\"Course Number\", num + 1, \"is\", course)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCourse Number 1 is STA 9750\nCourse Number 2 is STA 9708\nCourse Number 3 is STA 9700\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Looping sets\n\n`set` objects are looped in an unpredictable order\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmy_set = {\"cat\", \"dog\", \"cow\", \"horse\"}\nfor num, animal in enumerate(my_set):\n    print(\"Animal Number\", num + 1, \"is\", animal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnimal Number 1 is dog\nAnimal Number 2 is horse\nAnimal Number 3 is cat\nAnimal Number 4 is cow\n```\n\n\n:::\n:::\n\n\n\n\n\n\nOften **but not always** order of creation\n\n- Can't depend on this\n\n## Looping dicts\n\nBy default, a `dict` loops on its keys _only_\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nanimals = {\n    \"dog\": \"Canis familiaris\",\n    \"cat\": \"Felis catus\", \n    \"human\": \"Homo sapiens\",\n    \"cow\": \"Bos taurus\"\n}\nfor english in animals: \n    print(\"The Latin name for\", english, \"is\", animals[english])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe Latin name for dog is Canis familiaris\nThe Latin name for cat is Felis catus\nThe Latin name for human is Homo sapiens\nThe Latin name for cow is Bos taurus\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Looping dicts\n\nTo loop on key-value pairs use the `.items()` **method**\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nanimals = {\n    \"dog\": \"Canis familiaris\",\n    \"cat\": \"Felis catus\", \n    \"human\": \"Homo sapiens\",\n    \"cow\": \"Bos taurus\"\n}\nfor english, latin in animals.items(): \n    print(\"The Latin name for\", english, \"is\", latin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe Latin name for dog is Canis familiaris\nThe Latin name for cat is Felis catus\nThe Latin name for human is Homo sapiens\nThe Latin name for cow is Bos taurus\n```\n\n\n:::\n:::\n\n\n\n\n\n\n(We will cover methods in more detail later)\n\n## Comprehensions\n\n`python` allows compact a loop syntax called a _comprehension_\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = [1, 2, 3, 2, 1]\nx_sq = [n**2 for n in x]\n```\n:::\n\n\n\n\n\n\nCreates and captures `n**2` into a list automatically!\n\n. . . \n\nMuch nicer than: \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = [1, 2, 3, 2, 1]\nx_sq = []\nfor n in x:\n    x_sq.append(n**2)\n```\n:::\n\n\n\n\n\n\n## Comprehensions\n\nAlso supports `set` and `dict` comprehensions:\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = [1, 2, 3, 2, 1]\n[n**2 for n in x] # List comprehension\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 4, 9, 4, 1]\n```\n\n\n:::\n\n```{.python .cell-code}\n{n**2 for n in x} # Set comprehension (removes dupes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{1, 4, 9}\n```\n\n\n:::\n\n```{.python .cell-code}\n{n:n**2 for n in x} # Dict comprehension (key-value)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{1: 1, 2: 4, 3: 9}\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Comprehensions\n\nComprehensions can even nest conditionals:\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_squares = [n**2 for n in x if n % 2 == 0] \neven_squares\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[4, 16, 36, 64, 100]\n```\n\n\n:::\n:::\n\n\n\n\n\n\n. . . \n\nYou can do a lot inside a comprehension, but don't go crazy\n\n## Function calls\n\nBasic function calls look like `R`: \n\n> `function_name(argument1, argument2)`\n\nYou have already seen the `print()` and `enumerate()` functions\n\n## Function help\n\nYou can get help with the built-in `help` function: \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nhelp(print)\nhelp(enumerate)\n```\n:::\n\n\n\n\n\n\n## Keyword Arguments\n\nSometimes, we pass a named ('keyword') argument: \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(1, 2, 3, sep=\"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n2\n3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Keyword Arguments\n\nKeyword arguments must match _exactly_ and must come last\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(1, 2, 3, sep=\"\\n\", 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npositional argument follows keyword argument (<string>, line 1)\n```\n\n\n:::\n:::\n\n\n\n\n\n\n. . . \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(1, 2, 3, s=\"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTypeError: 's' is an invalid keyword argument for print()\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Defining Functions\n\nDefine custom functions with a `def` statement (not `=`)\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef say_hello(name):\n    print(\"Hello\", name, \"! It's great to meet you!\")\n\nsay_hello(\"Michael\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello Michael ! It's great to meet you!\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Defining Functions\n\nOptional arguments require defaults: \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef say_hello(name, message = \"It's great to meet you!\"):\n    print(\"Hello\", name, \"!\", message)\n\nsay_hello(\"Michael\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello Michael ! It's great to meet you!\n```\n\n\n:::\n\n```{.python .cell-code}\nsay_hello(\"Michael\", \"Welcome to STA 9750!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello Michael ! Welcome to STA 9750!\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Defining Functions\n\nCommon to use `None` (roughly equivalent to `R` `NULL`) for \n'missing'-type default values\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef say_hello(name, message = None):\n    if message: \n        print(\"Hello\", name, \"!\", message)\n    else: \n        print(\"Hello\", name, \"!\")\n\nsay_hello(\"Michael\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello Michael !\n```\n\n\n:::\n\n```{.python .cell-code}\nsay_hello(\"Michael\", \"Welcome to STA 9750!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello Michael ! Welcome to STA 9750!\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Put it Together!\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef say_hello(name, message = None):\n    if message: \n        print(\"Hello\", name, \"!\", message)\n    else: \n        print(\"Hello\", name, \"!\")\n\nstudents = [\"Alice\", \"Bob\", \"Carol\"]\n\n[say_hello(s) for s in students]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello Alice !\nHello Bob !\nHello Carol !\n[None, None, None]\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Put it Together!\n\nOr even \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n[say_hello(s, \"You are Student Number#\" + str(num)) \n  for num,s in enumerate(students)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello Alice ! You are Student Number#0\nHello Bob ! You are Student Number#1\nHello Carol ! You are Student Number#2\n[None, None, None]\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis is too complex - a plain loop is more readable here\n\n## Looking Ahead\n\n- Use Basic Syntax ✅\n- Manipulate Containers ✅\n- Iterate on Containers ✅\n- Call Functions ✅\n- Control Flow ✅\n\n. . . \n\nNext, moving beyond _basic_ `python` to data analysis: \n\n- Packages\n- The \"Object Model\"\n- Web Scraping and Data Import\n\n## Learning More\n\nSee [Chapter 3](https://wesmckinney.com/book/python-builtin) of *Python for Data Science*\n\n",
    "supporting": [
      "12_python_basics_control_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}